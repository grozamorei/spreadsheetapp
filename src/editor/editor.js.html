<script>

let blockingRequestRunning = false      // locked by running UI callbacks in editor form
let autoUpdateEnabled = true            // toggle auto update of cell selection
let selectionRequestRunning = false     // is cell selection update request running atm
let selectionRequestCallback = null     // UI callback in the editor form
let currentLocation = null              // last available row:col of the selection

let templateImmutables = ['id', 'parents', 'children', 'subjects']
let entityImmutables = ['template']

const maxPropertyNameLen = 12
const maxTemplateNameLen = 16
const allowedStringValue = /^[a-zA-Z0-9].*$/
const allowedNumberValue = /^[0-9].*$/
const allowedPropertyName = /^(?![0-9])[a-zA-Z0-9]{4,}$/
const allowedTemplateName = /^[A-Za-z]{4,}$/

function onServerCallSuccess() {
    removeAllChildren(document.getElementById('form'))

    currentLocation = null
    blockingRequestRunning = false
    makeRequest()    
}

function isBlocking(output) {
    if (blockingRequestRunning || selectionRequestCallback != null) {
        output.innerHTML = 'blocking operation'
        return true
    }
    return false
}

function drawEntityCreation(output, form, location, template) {
    const requestEntityCreation = function(location, dbDocument) {
        console.log('will create', dbDocument, 'at', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .createEntity(location, dbDocument)
    }

    output.innerHTML = 'no entity of type ' + template.id + '. create?'

    // const idCaption = createElement('pre')
    // idCaption.innerHTML = fillStringTo(maxPropertyNameLen, 'id')
    const inputs = {}
    for (let key in template) {
        const caption = createElement('pre', 'horizontal_element')
        caption.innerHTML = fillStringTo(maxPropertyNameLen, key)

        switch(template[key]) {
            case template.id:
            case 'string':
                const strInput = createInputElement('', 'horizontal_element', null, {'width': '85px'})
                strInput.setAttribute('maxlength', maxPropertyNameLen.toString())
                layoutElementsHorizontally(form, [caption, strInput])
                inputs[key] = {el: strInput, validator: null}
            break
            case 'link':
                const linkInput = createInputElement('', 'horizontal_element', null, {'width': '85px'})
                const btnAdd = createButtonElement('add', function() {

                })

                layoutElementsHorizontally(form, [caption, linkInput, btnAdd])
            break
            case 'number':
                const numInput = createInputElement('', 'horizontal_element', null, {'width': '85px', 'text-align': 'right'})
                layoutElementsHorizontally(form, [caption, numInput])
                inputs[key] = {el: numInput}
            break
        }
    }
}

function drawTemplatePropertyList(output, form, location, properties) {
    const requestErase = function(location) {
        console.log('will erase at ', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .eraseEntityTemplate(location.col)
    }

    const requestFieldAdd = function(location, fieldName, fieldType) {
        console.log('will create at', location, fieldName, fieldType)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .addEntityTemplateField(location.col, fieldName, fieldType)
    }

    const requestFieldErase = function(location, fieldName) {
        console.log('will erase property at', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .removeEntityTemplateField(location.col, fieldName)
    }
    output.innerHTML = properties.id

    let editableListKeys = []
    
    //
    // draw immutables first
    for (let key in properties) {
        if (templateImmutables.indexOf(key) === -1) {
            editableListKeys.push(key)
            continue
        }

        if (key === 'id') continue

        let pre = createElement('pre', null, form, {'margin': '3px', 'color': 'gray'})
        pre.innerHTML = fillStringTo(maxPropertyNameLen, key) + ': ' + properties[key]
    }

    //
    // draw existing additional properties
    for (let i = 0; i < editableListKeys.length; i++) {
        let key = editableListKeys[i]

        const pre = createElement('pre', null, form, {'margin': '3px', 'color': 'black'})
        pre.innerHTML = fillStringTo(maxPropertyNameLen, key) + ': ' + properties[key]

        const eraseCallObj = {f: requestFieldErase, args: [location, key]}
        const removeEl = createButtonElement('del', function() {
            if (isBlocking(output)) return
            output.innerHTML = 'requesting field remove..'
            selectionRequestCallback = eraseCallObj
        }, null, form, {'position': 'absolute', 'left': '200px', 'margin-top': '-18px', 'height': '16px', 'width': '32px'})
    }

    //
    // addition of the properties
    createElement('div', null, form, {'height': '20px'})
    const pLabel = createPElement('add property', 'horizontal_element', null,)
    const pNameField = createInputElement('', 'horizontal_element', null, {'width': '85px'})
    pNameField.setAttribute('maxlength', maxPropertyNameLen.toString())
    const pTypeField = createDropdown(['string', 'number', 'link', 'custom'], 'horizontal_element', null, {'width': '55px'})
    const pCreateBtn = createButtonElement('add', function() {
        if (!allowedPropertyName.test(pNameField.value)) {
            output.innerHTML = 'invalid name'
            return  
        }
        if (pNameField.value.toLowerCase() in properties) {
            output.innerHTML = 'cannot add matching name'
            return
        }

        if (isBlocking(output)) return

        output.innerHTML = 'requesting create..'
        selectionRequestCallback = {
            f: requestFieldAdd, 
            args: [location, pNameField.value.toLowerCase(), pTypeField.value]
        }
        
    }, 'horizontal_element', null, {'width': '40px'})
    layoutElementsHorizontally(form, [pLabel, pNameField, pTypeField, pCreateBtn])

    const removeBtn = createButtonElement('erase', function() {
        if (isBlocking(output)) return
        
        output.innerHTML = 'requesting erase..'
        selectionRequestCallback = {
            f: requestErase, 
            args: [location]
        }
        removeBtn.disabled = true
    }, null, form, {'margin-top': '40px', 'position': 'relative', 'left': '230px'})
}

function drawTemplateCreation(output, form, location) {
    const requestTemplateCreation = function(location, id, children, parents, special) {
        console.log('will create template ' + id + ' at ' + location.col)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .createEntityTemplate(location, id, children, parents, special)    
    }

    output.innerHTML = 'no entity template. create?'
                
    let idCaption = createPElement(null, 'template id', null, 'horizontal_element')
    let idInput = createInputElement('', 'horizontal_element')
    idInput.setAttribute('maxlength', maxTemplateNameLen.toString())
    layoutElementsHorizontally(form, [idCaption, idInput])

    let childrenBox, parentBox, specialBox
    
    childrenBox = createCheckBox('have children', form, function() {
        if (childrenBox.checked) specialBox.checked = false
    })
    parentBox = createCheckBox('have parents', form, function() {
        if (parentBox.checked) specialBox.checked = false
    })
    specialBox = createCheckBox('is special', form, function() {
        if (specialBox.checked) childrenBox.checked = parentBox.checked = false
    })

    let createBtn = createButtonElement('create', function() {
        if (!parentBox.checked && !childrenBox.checked && !specialBox.checked) {
            output.innerHTML = 'cannot create entity with no relations'
            return
        } 
        if (!allowedTemplateName.test(idInput.value)) {
            output.innerHTML = 'invalid name'
            return
        }

        if (isBlocking(output)) return

        output.innerHTML = 'creating entity template..'
        selectionRequestCallback = {
            f: requestTemplateCreation, 
            args: [
                location, 
                idInput.value.toLowerCase(), 
                childrenBox.checked, 
                parentBox.checked, 
                specialBox.checked
            ]
        }
    }, 'vertical_element', form, {'margin-top': '10px'})
}

function route(res) {
    const title = document.getElementById('title')
    const output = document.getElementById('output')
    const form = document.getElementById('form')

    if (res.result === 'error') {
        title.innerHTML = 'ERROR'
        output.innerHTML = res.reason
        form.innerHTML = ""
    } else if (res.result === 'ok') {
        
        var newLocation = false
        if (currentLocation === null) {
            newLocation = true
            currentLocation = {row: res.location.row, col: res.location.col}
        } else {
            if (currentLocation.row !== res.location.row ||
                currentLocation.col !== res.location.col) {
                newLocation = true
                currentLocation = {row: res.location.row, col: res.location.col}
            }
        }

        title.innerHTML = res.type + ' at [' + currentLocation.row + ':' + currentLocation.col + ']'

        if (!newLocation) return
        output.innerHTML = ''
        removeAllChildren(form)

        if (res.type === 'entityTemplate') {
            if (res.value.length === 0 || res.document.length === 0) {
                drawTemplateCreation(output, form, res.location)
            } else {
                drawTemplatePropertyList(output, form, res.location, JSON.parse(res.document))
            }
        } else if (res.type === 'entity') {
            if (res.template.length === 0) {
                output.innerHTML = "No template for this entity."
            } else {
                if (res.value.length === 0 || res.document.length === 0) {
                    drawEntityCreation(output, form, res.location, JSON.parse(res.template))
                } else {
                    output.innerHTML = "Entity editor will be here"
                }
            }
        }
    }
}

function makeRequest() {
    if (blockingRequestRunning) return

    selectionRequestRunning = true
    google.script.run.withSuccessHandler(function(res) {
        selectionRequestRunning = false

        let canProceed = true
        if (selectionRequestCallback != null) {
            // console.log('update selection: stopped by UI callback!')
            canProceed = false
            blockingRequestRunning = true
            selectionRequestCallback.f.apply(null, selectionRequestCallback.args)
            selectionRequestCallback = null
        }

        if (!canProceed) return
        route(res)

        if (autoUpdateEnabled) {
            makeRequest()
        }
    }).getSelected()
}

function toggleAutoUpdate(value) {
    autoUpdateEnabled = value
    if (autoUpdateEnabled) {
        if (!selectionRequestRunning) {
            makeRequest()
        }
    }
}

makeRequest()  

</script>