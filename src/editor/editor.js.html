<script>

let blockingRequestRunning = false      // locked by running UI callbacks in editor form
let autoUpdateEnabled = true            // toggle auto update of cell selection
let selectionRequestRunning = false     // is cell selection update request running atm
let selectionRequestCallback = null     // UI callback in the editor form
let currentLocation = null              // last available row:col of the selection

let templateImmutables = ['id', 'parents', 'children', 'subjects']
let entityImmutables = ['template']
const templateTypes = ['string', 'number', 'link', 'range', 'enum']

const maxPropertyNameLen = 12
const maxTemplateNameLen = 16
const allowedStringValue = /^[a-zA-Z0-9].*$/
const allowedNumberValue = /^[0-9].*$/
const allowedPropertyName = /^(?![0-9])[a-zA-Z0-9]{4,}$/
const allowedTemplateName = /^[A-Za-z]{4,}$/

function onServerCallSuccess() {
    removeAllChildren(document.getElementById('form'))

    currentLocation = null
    blockingRequestRunning = false
    makeRequest()    
}

function isBlocking(output) {
    if (blockingRequestRunning || selectionRequestCallback != null) {
        output.innerHTML = 'blocking operation'
        return true
    }
    return false
}

function drawEntityCreation(output, form, location, template) {
    const requestEntityCreation = function(location, dbDocument) {
        console.log('will create', dbDocument, 'at', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .createEntity(location, dbDocument)
    }

    output.innerHTML = 'no entity of type ' + template.id + '. create?'

    const inputs = {}
    for (let key in template) {
        console.log(key)
        const caption = createElement('pre', 'horizontal_element', null, {'width': '170px'})
        caption.innerHTML = fillStringTo(maxPropertyNameLen, key)
        switch(template[key]) {
            case template.id:
            case 'string':
                caption.innerHTML += '[str]'
                const strInput = createInputElement('', 'horizontal_element', null, {'width': '100px'})
                strInput.setAttribute('maxlength', maxPropertyNameLen.toString())
                layoutElementsHorizontally(form, [caption, strInput])
                if (template[key] === template.id) {
                    inputs[key] = {el: strInput, isValid: function(value) { return allowedPropertyName.test(value) }}
                } else if (template[key] === 'string') {
                    inputs[key] = {el: strInput, isValid: function(value) { return true }}
                }
            break
            case 'link':
                caption.innerHTML += '[link]'
                const valueLabel = createElement('pre', 'horizontal_element', null, {'width': '20px'})
                valueLabel.innerHTML = '2'
                const slider = createElement('input', 'horizontal_element', null, {'width': '50px'})
                slider.setAttribute('type', 'range')
                slider.setAttribute('step', '1')
                slider.setAttribute('min', '0')
                slider.setAttribute('max', '10')
                slider.setAttribute('value', '2')
                slider.addEventListener('change', function() {
                    valueLabel.innerHTML = slider.value.toString()
                })
                slider.addEventListener('input', function() {
                    valueLabel.innerHTML = slider.value.toString()
                })

                const btnMinus = createButtonElement('-', function() {
                    slider.stepDown()
                    valueLabel.innerHTML = slider.value.toString()
                }, 'horizontal_element', null, {'width': '15px', 'height': '15px'})
                const btnPlus = createButtonElement('+', function() {
                    slider.stepUp()
                    valueLabel.innerHTML = slider.value.toString()
                }, 'horizontal_element', null, {'width': '15px', 'height': '15px'})

                layoutElementsHorizontally(form, [caption, valueLabel, btnMinus, slider, btnPlus])
                inputs[key] = {el: slider, isValid: function(value) { return true }}
            break
            case 'number':
                caption.innerHTML += '[nmbr]'
                const spacer = createElement('div', 'horizontal_element', null, {'width': '50px'})
                const numInput = createInputElement('', 'horizontal_element', null, {'width': '50px', 'text-align': 'right'})
                layoutElementsHorizontally(form, [caption, spacer, numInput])
                inputs[key] = {el: numInput, isValid: function(value) { return !Number.isNaN(Number(value)) }}
            break
            case 'range':
                caption.innerHTML += '[rng]'
                const minInput = createInputElement('0', 'horizontal_element', null, {'width': '20px', 'text-align': 'right'})
                const rangeSpacer = createElement('div', 'horizontal_element', null, {'width': '50px'})
                const rangePre = createElement('pre', 'horizontal_element', null, {'width': '10px'})
                rangePre.innerHTML = '-'
                const maxInput = createInputElement('10', 'horizontal_element', null, {'width': '20px', 'text-align': 'right'})
                layoutElementsHorizontally(form, [caption, rangeSpacer, minInput, rangePre, maxInput])
                const valueGetter = {
                    get value() {
                        return [Number.parseInt(minInput.value), Number.parseInt(maxInput.value)]
                    }
                }
                inputs[key] = {el: valueGetter, isValid: function(value) { 
                    if (Number.isNaN(value[0]) || Number.isNaN(value[1])) return false
                    return value[1] > value[0]
                }}
            break
        }
    }

    const createBtn = createButtonElement('createEntity', function() {
        const object = {}
        //
        // validate correctness of input
        let canCreate = true
        for (let k in inputs) {
            const value = inputs[k].el.value
            if (!inputs[k].isValid(value)) {
                canCreate = false
                output.innerHTML = 'field [' + k + '] is not valid'
                break
            }
            object[k] = value
        }

        if (canCreate) {
            output.innerHTML = 'will create object ' + object.id + '..'
            //
            // properly create new object
            console.log('template: ', template)
            console.log('meta object: ', object)
            const finalObject = {}
            for (let k in object) {
                const fieldType = template[k]
                switch(fieldType) {
                    case template.id:
                    case 'string':    
                        finalObject[k] = object[k]
                        break
                    case 'link':
                        finalObject[k] = []
                        for (let i = 0; i < Number.parseInt(object[k]); i++) {
                            finalObject[k].push('')
                        }
                        break
                    case 'number':
                        finalObject[k] = Number(object[k])
                        break
                    case 'range':
                        finalObject[k] = [object[k][0], object[k][1]]
                        break
                    default:
                        finalObject[k] = 'unknown type'
                        output.innerHTML = 'field [' + k + '] has unknown type'
                        canCreate = false
                        break
                }
            }
            if (canCreate) {
                output.innerHTML = 'requesting create..'
                selectionRequestCallback = {
                    f: requestEntityCreation,
                    args: [location, finalObject]
                }
            }
        }
    }, null, form, {'margin-top': '40px'})
}

function drawTemplatePropertyList(output, form, location, properties) {
    const requestErase = function(location) {
        console.log('will erase at ', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .eraseEntityTemplate(location.col)
    }

    const requestFieldAdd = function(location, fieldName, fieldType) {
        console.log('will create at', location, fieldName, fieldType)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .addEntityTemplateField(location.col, fieldName, fieldType)
    }

    const requestFieldErase = function(location, fieldName) {
        console.log('will erase property at', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .removeEntityTemplateField(location.col, fieldName)
    }
    output.innerHTML = properties.id

    let editableListKeys = []
    
    //
    // draw immutables first
    for (let key in properties) {
        if (templateImmutables.indexOf(key) === -1) {
            editableListKeys.push(key)
            continue
        }

        if (key === 'id') continue

        let pre = createElement('pre', null, form, {'margin': '3px', 'color': 'gray'})
        pre.innerHTML = fillStringTo(maxPropertyNameLen, key) + ': ' + properties[key]
    }

    //
    // draw existing additional properties
    for (let i = 0; i < editableListKeys.length; i++) {
        let key = editableListKeys[i]

        const pre = createElement('pre', null, form, {'margin': '3px', 'color': 'black'})
        pre.innerHTML = fillStringTo(maxPropertyNameLen, key) + ': ' + properties[key]

        const eraseCallObj = {f: requestFieldErase, args: [location, key]}
        const removeEl = createButtonElement('del', function() {
            if (isBlocking(output)) return
            output.innerHTML = 'requesting field remove..'
            selectionRequestCallback = eraseCallObj
        }, null, form, {'position': 'absolute', 'left': '200px', 'margin-top': '-18px', 'height': '16px', 'width': '32px'})
    }

    //
    // addition of the properties
    createElement('div', null, form, {'height': '20px'})
    const pLabel = createPElement('add property', 'horizontal_element', null,)
    const pNameField = createInputElement('', 'horizontal_element', null, {'width': '85px'})
    pNameField.setAttribute('maxlength', maxPropertyNameLen.toString())
    const pTypeField = createDropdown(templateTypes, 'horizontal_element', null, {'width': '55px'})
    const pCreateBtn = createButtonElement('add', function() {
        if (!allowedPropertyName.test(pNameField.value)) {
            output.innerHTML = 'invalid name'
            return  
        }
        if (pNameField.value.toLowerCase() in properties) {
            output.innerHTML = 'cannot add matching name'
            return
        }

        if (isBlocking(output)) return

        output.innerHTML = 'requesting create..'
        selectionRequestCallback = {
            f: requestFieldAdd, 
            args: [location, pNameField.value.toLowerCase(), pTypeField.value]
        }
        
    }, 'horizontal_element', null, {'width': '40px'})
    layoutElementsHorizontally(form, [pLabel, pNameField, pTypeField, pCreateBtn])

    const removeBtn = createButtonElement('erase', function() {
        if (isBlocking(output)) return
        
        output.innerHTML = 'requesting erase..'
        selectionRequestCallback = {
            f: requestErase, 
            args: [location]
        }
        removeBtn.disabled = true
    }, null, form, {'margin-top': '40px', 'position': 'relative', 'left': '230px'})
}

function drawTemplateCreation(output, form, location) {
    const requestTemplateCreation = function(location, id, children, parents, special) {
        console.log('will create template ' + id + ' at ' + location.col)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .createEntityTemplate(location, id, children, parents, special)    
    }

    output.innerHTML = 'no entity template. create?'
                
    let idCaption = createPElement(null, 'template id', null, 'horizontal_element')
    let idInput = createInputElement('', 'horizontal_element')
    idInput.setAttribute('maxlength', maxTemplateNameLen.toString())
    layoutElementsHorizontally(form, [idCaption, idInput])

    let childrenBox, parentBox, specialBox
    
    childrenBox = createCheckBox('have children', form, function() {
        if (childrenBox.checked) specialBox.checked = false
    })
    parentBox = createCheckBox('have parents', form, function() {
        if (parentBox.checked) specialBox.checked = false
    })
    specialBox = createCheckBox('is special', form, function() {
        if (specialBox.checked) childrenBox.checked = parentBox.checked = false
    })

    let createBtn = createButtonElement('create', function() {
        if (!parentBox.checked && !childrenBox.checked && !specialBox.checked) {
            output.innerHTML = 'cannot create entity with no relations'
            return
        } 
        if (!allowedTemplateName.test(idInput.value)) {
            output.innerHTML = 'invalid name'
            return
        }

        if (isBlocking(output)) return

        output.innerHTML = 'creating entity template..'
        selectionRequestCallback = {
            f: requestTemplateCreation, 
            args: [
                location, 
                idInput.value.toLowerCase(), 
                childrenBox.checked, 
                parentBox.checked, 
                specialBox.checked
            ]
        }
    }, 'vertical_element', form, {'margin-top': '10px'})
}

function route(res) {
    const title = document.getElementById('title')
    const output = document.getElementById('output')
    const form = document.getElementById('form')

    if (res.result === 'error') {
        title.innerHTML = 'ERROR'
        output.innerHTML = res.reason
        form.innerHTML = ""
    } else if (res.result === 'ok') {
        
        var newLocation = false
        if (currentLocation === null) {
            newLocation = true
            currentLocation = {row: res.location.row, col: res.location.col}
        } else {
            if (currentLocation.row !== res.location.row ||
                currentLocation.col !== res.location.col) {
                newLocation = true
                currentLocation = {row: res.location.row, col: res.location.col}
            }
        }

        title.innerHTML = res.type + ' at [' + currentLocation.row + ':' + currentLocation.col + ']'

        if (!newLocation) return
        output.innerHTML = ''
        removeAllChildren(form)

        if (res.type === 'entityTemplate') {
            if (res.value.length === 0 || res.document.length === 0) {
                drawTemplateCreation(output, form, res.location)
            } else {
                drawTemplatePropertyList(output, form, res.location, JSON.parse(res.document))
            }
        } else if (res.type === 'entity') {
            if (res.template.length === 0) {
                output.innerHTML = "No template for this entity."
            } else {
                if (res.value.length === 0 || res.document.length === 0) {
                    drawEntityCreation(output, form, res.location, JSON.parse(res.template))
                } else {
                    output.innerHTML = "Entity editor will be here"
                }
            }
        }
    }
}

function makeRequest() {
    if (blockingRequestRunning) return

    selectionRequestRunning = true
    google.script.run.withSuccessHandler(function(res) {
        selectionRequestRunning = false

        let canProceed = true
        if (selectionRequestCallback != null) {
            // console.log('update selection: stopped by UI callback!')
            canProceed = false
            blockingRequestRunning = true
            selectionRequestCallback.f.apply(null, selectionRequestCallback.args)
            selectionRequestCallback = null
        }

        if (!canProceed) return
        route(res)

        if (autoUpdateEnabled) {
            makeRequest()
        }
    }).getSelected()
}

function toggleAutoUpdate(value) {
    autoUpdateEnabled = value
    if (autoUpdateEnabled) {
        if (!selectionRequestRunning) {
            makeRequest()
        }
    }
}

makeRequest()  

</script>