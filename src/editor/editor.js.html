<script>

let blockingRequestRunning = false      // locked by running UI callbacks in editor form
let autoUpdateEnabled = true            // toggle auto update of cell selection
let selectionRequestRunning = false     // is cell selection update request running atm
let selectionRequestCallback = null     // UI callback in the editor form
let currentLocation = null              // last available row:col of the selection

let templateImmutables = ['id', 'parents', 'children', 'subjects']
let entityImmutables = ['template']
const templateTypes = ['string', 'number', 'link', 'range', 'enum']
const objectTypes = ['string', 'number', 'link', 'range', 'enum']

const maxPropertyNameLen = 12
const maxTemplateNameLen = 16
const allowedStringValue = /^[a-zA-Z0-9].*$/
const allowedNumberValue = /^[0-9].*$/
const allowedPropertyName = /^(?![0-9])[a-zA-Z0-9]{4,}$/
const allowedTemplateName = /^[A-Za-z]{4,}$/

function onServerCallSuccess() {
    removeAllChildren(document.getElementById('form'))

    currentLocation = null
    blockingRequestRunning = false
    makeRequest()    
}

const isBlocking = (function(output) {
    return function() {
        if (blockingRequestRunning || selectionRequestCallback != null) {
            output.innerHTML = 'blocking operation'
            return true
        }
        return false    
    }
})(document.getElementById('output'))

function drawEntityEditor() {
    // for string
    // inputs[key] = bake(VALIDATOR.alwaysValid, inputComponent('', 100, 0, 'left'))
    // for input
    // inputs[key] = bake(VALIDATOR.forNumber, inputComponent('0', 50, 0, 'right'))
    // for range
    // inputs[key] = bake(VALIDATOR.forRange, rangeComponent(0, 10))
    //
    // array editor
    // var redrawElements = function(subform, length) {
    //     const previousValues = []
    //     for (let i = 0; i < subform.children.length; i++) {
    //         const input = subform.children[i].children[1]
    //         previousValues.push(input.value)
    //     }
    //     removeAllChildren(subform)
    //     for (let i = 0; i < length; i++) {
    //         const spacer = createElement('div', 'horizontal_element', null, {'width': '170px'})
    //         initBaker(subform, [spacer])(VALIDATOR.forRegExp(allowedPropertyName), inputComponent(previousValues[i] || '', 100, 0, 'left'))
    //     }    
    // }

    // var subform
    // var slider = bake(VALIDATOR.alwaysValid, sliderComponent(2, 20, 1, 3, function() { 
    //     redrawElements(subform, slider.el.value) 
    // }))
    // subform = createElement('div', '', form)
    // redrawElements(subform, slider.el.value)


    //
    // validations
    const createBtn = createButtonElement('createEntity', function() {
        const object = {}
        //
        // validate correctness of input
        let canCreate = true
        for (let k in inputs) {
            const value = inputs[k].el.value
            if (!inputs[k].isValid(value)) {
                canCreate = false
                output.innerHTML = 'field [' + k + '] is not valid'
                break
            }
            object[k] = value
        }

        if (canCreate) {
            output.innerHTML = 'will create object ' + object.id + '..'
            //
            // properly create new object
            console.log('template: ', template)
            console.log('meta object: ', object)
            const finalObject = {}
            for (let k in object) {
                const fieldType = template[k]
                switch(fieldType) {
                    case template.id:
                    case 'string':    
                        finalObject[k] = object[k]
                        break
                    case 'link':
                        finalObject[k] = []
                        for (let i = 0; i < Number.parseInt(object[k]); i++) {
                            finalObject[k].push('')
                        }
                        break
                    case 'number':
                        finalObject[k] = Number(object[k])
                        break
                    case 'range':
                        finalObject[k] = [object[k][0], object[k][1]]
                        break
                    case 'enum':
                        finalObject[k] = ['', '']
                        break
                    default:
                        finalObject[k] = 'unknown type'
                        output.innerHTML = 'field [' + k + '] has unknown type'
                        canCreate = false
                        break
                }
            }
            if (canCreate) {
                output.innerHTML = 'requesting create..'
                selectionRequestCallback = {
                    f: requestEntityCreation,
                    args: [location, finalObject]
                }
            }
        }
    }, null, form, {'margin-top': '40px'})
}

function drawEntityCreation(output, form, location, template) {
    const requestEntityCreation = function(location, dbDocument) {
        console.log('will create', dbDocument, 'at', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .createEntity(location, dbDocument)
    }

    output.innerHTML = 'no entity of type ' + template.id + '. create?'

    const inputs = {}
    for (let key in template) {
        const caption = createElement('pre', 'horizontal_element', null, {'width': '170px'})
        caption.innerHTML = fillStringTo(maxPropertyNameLen, key) + typeToAnnotation(template, key)
        const bake = initBaker(form, [caption])
        
        switch(template[key]) {
            case template.id:
                inputs[key] = bake(
                    VALIDATOR.forRegExp(allowedPropertyName), 
                    inputComponent('', 100, maxPropertyNameLen, 'left')
                )
            break
            case 'link':
                inputs[key] = bake(VALIDATOR.alwaysValid, sliderComponent(0, 10, 1, 2))
            break
            default:
                drawImmutableField(form, maxPropertyNameLen, key, template[key])
        }
    }

    const createBtn = createButtonElement('createEntity', function() {
        //
        // validate correctness of input
        let canCreate, object
        [canCreate, object] = checkInputs(inputs, output)

        if (canCreate) {
            output.innerHTML = 'will create object ' + object.id + '..'
            //
            // properly create new object
            console.log('template: ', template)
            console.log('meta object: ', object)
            const finalObject = {}
            for (let k in object) {
                const fieldType = template[k]
                switch(fieldType) {
                    case template.id:
                        finalObject[k] = object[k]
                        break
                    case 'link':
                        finalObject[k] = []
                        for (let i = 0; i < Number.parseInt(object[k]); i++) {
                            finalObject[k].push('')
                        }
                        break
                    default:
                        finalObject[k] = 'unknown type'
                        output.innerHTML = 'field [' + k + '] has unknown type'
                        canCreate = false
                        break
                }
            }
            if (canCreate) {
                for (let key in template) {
                    if (key in object) continue
                    finalObject[key] = template[key]
                }
                output.innerHTML = 'requesting create..'
                selectionRequestCallback = {
                    f: requestEntityCreation,
                    args: [location, finalObject]
                }
            }
        }
    }, null, form, {'margin-top': '40px'})
}

function drawTemplatePropertyList(output, form, location, properties) {
    const requestErase = function(location) {
        console.log('will erase at ', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .eraseEntityTemplate(location.col)
    }

    const requestFieldAdd = function(location, fieldName, fieldType) {
        console.log('will create at', location, fieldName, fieldType)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .addEntityTemplateField(location.col, fieldName, fieldType)
    }

    const requestFieldErase = function(location, fieldName) {
        console.log('will erase property at', location)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .removeEntityTemplateField(location.col, fieldName)
    }
    output.innerHTML = properties.id

    let editableListKeys = []
    
    //
    // draw immutables first
    for (let key in properties) {
        if (templateImmutables.indexOf(key) === -1) {
            editableListKeys.push(key)
            continue
        }

        if (key === 'id') continue
        drawImmutableField(form, maxPropertyNameLen, key, properties[key])
    }

    //
    // draw existing additional properties
    for (let i = 0; i < editableListKeys.length; i++) {
        let key = editableListKeys[i]

        const eraseCallObj = {f: requestFieldErase, args: [location, key]}
        drawErasableField(form, maxPropertyNameLen, key, properties[key], function() {
            if (isBlocking()) return
            output.innerHTML = 'requesting field remove..'
            selectionRequestCallback = eraseCallObj
        })
    }

    //
    // addition of the properties
    createElement('div', null, form, {'height': '20px'})
    const pLabel = createPElement('add property', 'horizontal_element', null,)
    const pNameField = createInputElement('', 'horizontal_element', null, {'width': '85px'})
    pNameField.setAttribute('maxlength', maxPropertyNameLen.toString())
    const pTypeField = createDropdown(templateTypes, 'horizontal_element', null, {'width': '55px'})
    const pCreateBtn = createButtonElement('add', function() {
        if (!allowedPropertyName.test(pNameField.value)) {
            output.innerHTML = 'invalid name'
            return  
        }
        if (pNameField.value.toLowerCase() in properties) {
            output.innerHTML = 'cannot add matching name'
            return
        }

        if (isBlocking()) return

        output.innerHTML = 'requesting create..'
        selectionRequestCallback = {
            f: requestFieldAdd, 
            args: [location, pNameField.value.toLowerCase(), pTypeField.value]
        }
        
    }, 'horizontal_element', null, {'width': '40px'})
    layoutElementsHorizontally(form, [pLabel, pNameField, pTypeField, pCreateBtn])

    const removeBtn = createButtonElement('erase', function() {
        if (isBlocking()) return
        
        output.innerHTML = 'requesting erase..'
        selectionRequestCallback = {
            f: requestErase, 
            args: [location]
        }
        removeBtn.disabled = true
    }, null, form, {'margin-top': '40px', 'position': 'relative', 'left': '230px'})
}

function drawTemplateCreation(output, form, location) {
    const requestTemplateCreation = function(location, id, children, parents, special) {
        console.log('will create template ' + id + ' at ' + location.col)
        google.script.run
            .withSuccessHandler(onServerCallSuccess)
            .createEntityTemplate(location, id, children, parents, special)    
    }

    output.innerHTML = 'no entity template. create?'
                
    let idCaption = createPElement(null, 'template id', null, 'horizontal_element')
    let idInput = createInputElement('', 'horizontal_element')
    idInput.setAttribute('maxlength', maxTemplateNameLen.toString())
    layoutElementsHorizontally(form, [idCaption, idInput])

    let childrenBox, parentBox, specialBox
    
    childrenBox = createCheckBox('have children', form, function() {
        if (childrenBox.checked) specialBox.checked = false
    })
    parentBox = createCheckBox('have parents', form, function() {
        if (parentBox.checked) specialBox.checked = false
    })
    specialBox = createCheckBox('is special', form, function() {
        if (specialBox.checked) childrenBox.checked = parentBox.checked = false
    })

    let createBtn = createButtonElement('create', function() {
        if (!parentBox.checked && !childrenBox.checked && !specialBox.checked) {
            output.innerHTML = 'cannot create entity with no relations'
            return
        } 
        if (!allowedTemplateName.test(idInput.value)) {
            output.innerHTML = 'invalid name'
            return
        }

        if (isBlocking()) return

        output.innerHTML = 'creating entity template..'
        selectionRequestCallback = {
            f: requestTemplateCreation, 
            args: [
                location, 
                idInput.value.toLowerCase(), 
                childrenBox.checked, 
                parentBox.checked, 
                specialBox.checked
            ]
        }
    }, 'vertical_element', form, {'margin-top': '10px'})
}

function route(res) {
    const title = document.getElementById('title')
    const output = document.getElementById('output')
    const form = document.getElementById('form')

    if (res.result === 'error') {
        title.innerHTML = 'ERROR'
        output.innerHTML = res.reason
        form.innerHTML = ""
    } else if (res.result === 'ok') {
        
        var newLocation = false
        if (currentLocation === null) {
            newLocation = true
            currentLocation = {row: res.location.row, col: res.location.col}
        } else {
            if (currentLocation.row !== res.location.row ||
                currentLocation.col !== res.location.col) {
                newLocation = true
                currentLocation = {row: res.location.row, col: res.location.col}
            }
        }

        title.innerHTML = res.type + ' at [' + currentLocation.row + ':' + currentLocation.col + ']'

        if (!newLocation) return
        output.innerHTML = ''
        removeAllChildren(form)

        if (res.type === 'entityTemplate') {
            if (res.value.length === 0 || res.document.length === 0) {
                drawTemplateCreation(output, form, res.location)
            } else {
                drawTemplatePropertyList(output, form, res.location, JSON.parse(res.document))
            }
        } else if (res.type === 'entity') {
            if (res.template.length === 0) {
                output.innerHTML = "No template for this entity."
            } else {
                if (res.value.length === 0 || res.document.length === 0) {
                    drawEntityCreation(output, form, res.location, JSON.parse(res.template))
                } else {
                    output.innerHTML = "Entity editor will be here"
                }
            }
        }
    }
}

function makeRequest() {
    if (blockingRequestRunning) return

    selectionRequestRunning = true
    google.script.run.withSuccessHandler(function(res) {
        selectionRequestRunning = false

        let canProceed = true
        if (selectionRequestCallback != null) {
            // console.log('update selection: stopped by UI callback!')
            canProceed = false
            blockingRequestRunning = true
            selectionRequestCallback.f.apply(null, selectionRequestCallback.args)
            selectionRequestCallback = null
        }

        if (!canProceed) return
        route(res)

        if (autoUpdateEnabled) {
            makeRequest()
        }
    }).getSelected()
}

function toggleAutoUpdate(value) {
    autoUpdateEnabled = value
    if (autoUpdateEnabled) {
        if (!selectionRequestRunning) {
            makeRequest()
        }
    }
}

makeRequest()


</script>